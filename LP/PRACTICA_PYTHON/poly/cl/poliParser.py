# Generated from poli.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\36")
        buf.write("\u0092\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\3\2")
        buf.write("\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3")
        buf.write("\2\3\2\3\2\3\2\3\2\5\2.\n\2\3\3\3\3\3\3\3\3\3\3\5\3\65")
        buf.write("\n\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3=\n\3\5\3?\n\3\3\4\3\4")
        buf.write("\3\4\3\5\3\5\7\5F\n\5\f\5\16\5I\13\5\3\5\3\5\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3\t")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\7\tv\n")
        buf.write("\t\f\t\16\ty\13\t\5\t{\n\t\3\n\3\n\3\n\3\13\3\13\3\13")
        buf.write("\3\13\5\13\u0084\n\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\5\f\u008e\n\f\3\r\3\r\3\r\2\2\16\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\2\3\3\2\32\33\2\u009d\2-\3\2\2\2\4>\3\2\2\2")
        buf.write("\6@\3\2\2\2\bC\3\2\2\2\nL\3\2\2\2\fR\3\2\2\2\16V\3\2\2")
        buf.write("\2\20z\3\2\2\2\22|\3\2\2\2\24\u0083\3\2\2\2\26\u008d\3")
        buf.write("\2\2\2\30\u008f\3\2\2\2\32\33\5\16\b\2\33\34\7\2\2\3\34")
        buf.write(".\3\2\2\2\35\36\5\20\t\2\36\37\7\2\2\3\37.\3\2\2\2 !\5")
        buf.write("\26\f\2!\"\7\2\2\3\".\3\2\2\2#$\5\24\13\2$%\7\2\2\3%.")
        buf.write("\3\2\2\2&\'\5\22\n\2\'(\7\2\2\3(.\3\2\2\2)*\5\f\7\2*+")
        buf.write("\7\2\2\3+.\3\2\2\2,.\7\2\2\3-\32\3\2\2\2-\35\3\2\2\2-")
        buf.write(" \3\2\2\2-#\3\2\2\2-&\3\2\2\2-)\3\2\2\2-,\3\2\2\2.\3\3")
        buf.write("\2\2\2/\64\7\7\2\2\60\65\5\30\r\2\61\65\5\b\5\2\62\65")
        buf.write("\5\24\13\2\63\65\5\26\f\2\64\60\3\2\2\2\64\61\3\2\2\2")
        buf.write("\64\62\3\2\2\2\64\63\3\2\2\2\65\66\3\2\2\2\66\67\7\b\2")
        buf.write("\2\67?\3\2\2\28=\5\30\r\29=\5\b\5\2:=\5\24\13\2;=\5\26")
        buf.write("\f\2<8\3\2\2\2<9\3\2\2\2<:\3\2\2\2<;\3\2\2\2=?\3\2\2\2")
        buf.write(">/\3\2\2\2><\3\2\2\2?\5\3\2\2\2@A\t\2\2\2AB\t\2\2\2B\7")
        buf.write("\3\2\2\2CG\7\3\2\2DF\5\6\4\2ED\3\2\2\2FI\3\2\2\2GE\3\2")
        buf.write("\2\2GH\3\2\2\2HJ\3\2\2\2IG\3\2\2\2JK\7\4\2\2K\t\3\2\2")
        buf.write("\2LM\7\5\2\2MN\t\2\2\2NO\t\2\2\2OP\t\2\2\2PQ\7\6\2\2Q")
        buf.write("\13\3\2\2\2RS\5\30\r\2ST\7\n\2\2TU\5\4\3\2U\r\3\2\2\2")
        buf.write("VW\7\13\2\2WX\5\30\r\2XY\7\t\2\2YZ\5\n\6\2Z\17\3\2\2\2")
        buf.write("[\\\7\r\2\2\\{\5\4\3\2]^\7\16\2\2^{\5\4\3\2_`\7\17\2\2")
        buf.write("`{\5\4\3\2ab\7\20\2\2b{\5\4\3\2cd\7\f\2\2d{\5\4\3\2ef")
        buf.write("\7\22\2\2fg\5\4\3\2gh\7\t\2\2hi\5\4\3\2i{\3\2\2\2jk\7")
        buf.write("\21\2\2kl\5\4\3\2lm\7\t\2\2mn\5\4\3\2n{\3\2\2\2op\7\23")
        buf.write("\2\2pq\7\30\2\2qr\7\t\2\2rw\5\4\3\2st\7\t\2\2tv\5\4\3")
        buf.write("\2us\3\2\2\2vy\3\2\2\2wu\3\2\2\2wx\3\2\2\2x{\3\2\2\2y")
        buf.write("w\3\2\2\2z[\3\2\2\2z]\3\2\2\2z_\3\2\2\2za\3\2\2\2zc\3")
        buf.write("\2\2\2ze\3\2\2\2zj\3\2\2\2zo\3\2\2\2{\21\3\2\2\2|}\7\f")
        buf.write("\2\2}~\7\30\2\2~\23\3\2\2\2\177\u0080\7\26\2\2\u0080\u0084")
        buf.write("\5\4\3\2\u0081\u0082\7\27\2\2\u0082\u0084\7\32\2\2\u0083")
        buf.write("\177\3\2\2\2\u0083\u0081\3\2\2\2\u0084\25\3\2\2\2\u0085")
        buf.write("\u0086\5\30\r\2\u0086\u0087\7\24\2\2\u0087\u0088\5\4\3")
        buf.write("\2\u0088\u008e\3\2\2\2\u0089\u008a\5\30\r\2\u008a\u008b")
        buf.write("\7\25\2\2\u008b\u008c\5\4\3\2\u008c\u008e\3\2\2\2\u008d")
        buf.write("\u0085\3\2\2\2\u008d\u0089\3\2\2\2\u008e\27\3\2\2\2\u008f")
        buf.write("\u0090\7\31\2\2\u0090\31\3\2\2\2\13-\64<>Gwz\u0083\u008d")
        return buf.getvalue()


class poliParser ( Parser ):

    grammarFileName = "poli.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'['", "']'", "'{'", "'}'", "'('", "')'", 
                     "','", "':='", "'color'", "'print'", "'area'", "'perimeter'", 
                     "'vertices'", "'centroid'", "'inside'", "'equal'", 
                     "'draw'", "'+'", "'*'", "'#'", "'!'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'\n'" ]

    symbolicNames = [ "<INVALID>", "OPENLIST", "CLSELIST", "OPENCOLOR", 
                      "CLSECOLOR", "OPENEXP", "CLSEEXP", "COMA", "ASSIGN", 
                      "CMDCOLOR", "CMDPRINT", "CMDAREA", "CMDPERIMETRE", 
                      "CMDVERTICES", "CMDCENTROID", "CMDINSIDE", "CMDEQ", 
                      "CMDDRAW", "OPERATORUNION", "OPERATORINTER", "OPERATORBOUNDINGBOX", 
                      "OPERATORRANDOMPOLY", "TXT", "ID", "INT", "FLOAT", 
                      "ENDLINE", "COMMENT", "WS" ]

    RULE_root = 0
    RULE_poly = 1
    RULE_vertex = 2
    RULE_vertexList = 3
    RULE_colorList = 4
    RULE_newPoly = 5
    RULE_assignColor = 6
    RULE_consultaPOLY = 7
    RULE_printMSG = 8
    RULE_operacionsPOLY1 = 9
    RULE_operacionsPOLY2 = 10
    RULE_polyID = 11

    ruleNames =  [ "root", "poly", "vertex", "vertexList", "colorList", 
                   "newPoly", "assignColor", "consultaPOLY", "printMSG", 
                   "operacionsPOLY1", "operacionsPOLY2", "polyID" ]

    EOF = Token.EOF
    OPENLIST=1
    CLSELIST=2
    OPENCOLOR=3
    CLSECOLOR=4
    OPENEXP=5
    CLSEEXP=6
    COMA=7
    ASSIGN=8
    CMDCOLOR=9
    CMDPRINT=10
    CMDAREA=11
    CMDPERIMETRE=12
    CMDVERTICES=13
    CMDCENTROID=14
    CMDINSIDE=15
    CMDEQ=16
    CMDDRAW=17
    OPERATORUNION=18
    OPERATORINTER=19
    OPERATORBOUNDINGBOX=20
    OPERATORRANDOMPOLY=21
    TXT=22
    ID=23
    INT=24
    FLOAT=25
    ENDLINE=26
    COMMENT=27
    WS=28

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class RootContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignColor(self):
            return self.getTypedRuleContext(poliParser.AssignColorContext,0)


        def EOF(self):
            return self.getToken(poliParser.EOF, 0)

        def consultaPOLY(self):
            return self.getTypedRuleContext(poliParser.ConsultaPOLYContext,0)


        def operacionsPOLY2(self):
            return self.getTypedRuleContext(poliParser.OperacionsPOLY2Context,0)


        def operacionsPOLY1(self):
            return self.getTypedRuleContext(poliParser.OperacionsPOLY1Context,0)


        def printMSG(self):
            return self.getTypedRuleContext(poliParser.PrintMSGContext,0)


        def newPoly(self):
            return self.getTypedRuleContext(poliParser.NewPolyContext,0)


        def getRuleIndex(self):
            return poliParser.RULE_root

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoot" ):
                return visitor.visitRoot(self)
            else:
                return visitor.visitChildren(self)




    def root(self):

        localctx = poliParser.RootContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_root)
        try:
            self.state = 43
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 24
                self.assignColor()
                self.state = 25
                self.match(poliParser.EOF)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 27
                self.consultaPOLY()
                self.state = 28
                self.match(poliParser.EOF)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 30
                self.operacionsPOLY2()
                self.state = 31
                self.match(poliParser.EOF)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 33
                self.operacionsPOLY1()
                self.state = 34
                self.match(poliParser.EOF)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 36
                self.printMSG()
                self.state = 37
                self.match(poliParser.EOF)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 39
                self.newPoly()
                self.state = 40
                self.match(poliParser.EOF)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 42
                self.match(poliParser.EOF)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PolyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPENEXP(self):
            return self.getToken(poliParser.OPENEXP, 0)

        def CLSEEXP(self):
            return self.getToken(poliParser.CLSEEXP, 0)

        def polyID(self):
            return self.getTypedRuleContext(poliParser.PolyIDContext,0)


        def vertexList(self):
            return self.getTypedRuleContext(poliParser.VertexListContext,0)


        def operacionsPOLY1(self):
            return self.getTypedRuleContext(poliParser.OperacionsPOLY1Context,0)


        def operacionsPOLY2(self):
            return self.getTypedRuleContext(poliParser.OperacionsPOLY2Context,0)


        def getRuleIndex(self):
            return poliParser.RULE_poly

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPoly" ):
                return visitor.visitPoly(self)
            else:
                return visitor.visitChildren(self)




    def poly(self):

        localctx = poliParser.PolyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_poly)
        try:
            self.state = 60
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [poliParser.OPENEXP]:
                self.enterOuterAlt(localctx, 1)
                self.state = 45
                self.match(poliParser.OPENEXP)
                self.state = 50
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
                if la_ == 1:
                    self.state = 46
                    self.polyID()
                    pass

                elif la_ == 2:
                    self.state = 47
                    self.vertexList()
                    pass

                elif la_ == 3:
                    self.state = 48
                    self.operacionsPOLY1()
                    pass

                elif la_ == 4:
                    self.state = 49
                    self.operacionsPOLY2()
                    pass


                self.state = 52
                self.match(poliParser.CLSEEXP)
                pass
            elif token in [poliParser.OPENLIST, poliParser.OPERATORBOUNDINGBOX, poliParser.OPERATORRANDOMPOLY, poliParser.ID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 58
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                if la_ == 1:
                    self.state = 54
                    self.polyID()
                    pass

                elif la_ == 2:
                    self.state = 55
                    self.vertexList()
                    pass

                elif la_ == 3:
                    self.state = 56
                    self.operacionsPOLY1()
                    pass

                elif la_ == 4:
                    self.state = 57
                    self.operacionsPOLY2()
                    pass


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VertexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(poliParser.INT)
            else:
                return self.getToken(poliParser.INT, i)

        def FLOAT(self, i:int=None):
            if i is None:
                return self.getTokens(poliParser.FLOAT)
            else:
                return self.getToken(poliParser.FLOAT, i)

        def getRuleIndex(self):
            return poliParser.RULE_vertex

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVertex" ):
                return visitor.visitVertex(self)
            else:
                return visitor.visitChildren(self)




    def vertex(self):

        localctx = poliParser.VertexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_vertex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            _la = self._input.LA(1)
            if not(_la==poliParser.INT or _la==poliParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 63
            _la = self._input.LA(1)
            if not(_la==poliParser.INT or _la==poliParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VertexListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPENLIST(self):
            return self.getToken(poliParser.OPENLIST, 0)

        def CLSELIST(self):
            return self.getToken(poliParser.CLSELIST, 0)

        def vertex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(poliParser.VertexContext)
            else:
                return self.getTypedRuleContext(poliParser.VertexContext,i)


        def getRuleIndex(self):
            return poliParser.RULE_vertexList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVertexList" ):
                return visitor.visitVertexList(self)
            else:
                return visitor.visitChildren(self)




    def vertexList(self):

        localctx = poliParser.VertexListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_vertexList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65
            self.match(poliParser.OPENLIST)
            self.state = 69
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==poliParser.INT or _la==poliParser.FLOAT:
                self.state = 66
                self.vertex()
                self.state = 71
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 72
            self.match(poliParser.CLSELIST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ColorListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPENCOLOR(self):
            return self.getToken(poliParser.OPENCOLOR, 0)

        def CLSECOLOR(self):
            return self.getToken(poliParser.CLSECOLOR, 0)

        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(poliParser.INT)
            else:
                return self.getToken(poliParser.INT, i)

        def FLOAT(self, i:int=None):
            if i is None:
                return self.getTokens(poliParser.FLOAT)
            else:
                return self.getToken(poliParser.FLOAT, i)

        def getRuleIndex(self):
            return poliParser.RULE_colorList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColorList" ):
                return visitor.visitColorList(self)
            else:
                return visitor.visitChildren(self)




    def colorList(self):

        localctx = poliParser.ColorListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_colorList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.match(poliParser.OPENCOLOR)
            self.state = 75
            _la = self._input.LA(1)
            if not(_la==poliParser.INT or _la==poliParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 76
            _la = self._input.LA(1)
            if not(_la==poliParser.INT or _la==poliParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 77
            _la = self._input.LA(1)
            if not(_la==poliParser.INT or _la==poliParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 78
            self.match(poliParser.CLSECOLOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NewPolyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def polyID(self):
            return self.getTypedRuleContext(poliParser.PolyIDContext,0)


        def ASSIGN(self):
            return self.getToken(poliParser.ASSIGN, 0)

        def poly(self):
            return self.getTypedRuleContext(poliParser.PolyContext,0)


        def getRuleIndex(self):
            return poliParser.RULE_newPoly

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNewPoly" ):
                return visitor.visitNewPoly(self)
            else:
                return visitor.visitChildren(self)




    def newPoly(self):

        localctx = poliParser.NewPolyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_newPoly)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.polyID()
            self.state = 81
            self.match(poliParser.ASSIGN)
            self.state = 82
            self.poly()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignColorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CMDCOLOR(self):
            return self.getToken(poliParser.CMDCOLOR, 0)

        def polyID(self):
            return self.getTypedRuleContext(poliParser.PolyIDContext,0)


        def colorList(self):
            return self.getTypedRuleContext(poliParser.ColorListContext,0)


        def getRuleIndex(self):
            return poliParser.RULE_assignColor

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignColor" ):
                return visitor.visitAssignColor(self)
            else:
                return visitor.visitChildren(self)




    def assignColor(self):

        localctx = poliParser.AssignColorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_assignColor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.match(poliParser.CMDCOLOR)
            self.state = 85
            self.polyID()
            self.state = 86
            self.match(poliParser.COMA)
            self.state = 87
            self.colorList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConsultaPOLYContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CMDAREA(self):
            return self.getToken(poliParser.CMDAREA, 0)

        def poly(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(poliParser.PolyContext)
            else:
                return self.getTypedRuleContext(poliParser.PolyContext,i)


        def CMDPERIMETRE(self):
            return self.getToken(poliParser.CMDPERIMETRE, 0)

        def CMDVERTICES(self):
            return self.getToken(poliParser.CMDVERTICES, 0)

        def CMDCENTROID(self):
            return self.getToken(poliParser.CMDCENTROID, 0)

        def CMDPRINT(self):
            return self.getToken(poliParser.CMDPRINT, 0)

        def CMDEQ(self):
            return self.getToken(poliParser.CMDEQ, 0)

        def COMA(self, i:int=None):
            if i is None:
                return self.getTokens(poliParser.COMA)
            else:
                return self.getToken(poliParser.COMA, i)

        def CMDINSIDE(self):
            return self.getToken(poliParser.CMDINSIDE, 0)

        def CMDDRAW(self):
            return self.getToken(poliParser.CMDDRAW, 0)

        def TXT(self):
            return self.getToken(poliParser.TXT, 0)

        def getRuleIndex(self):
            return poliParser.RULE_consultaPOLY

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsultaPOLY" ):
                return visitor.visitConsultaPOLY(self)
            else:
                return visitor.visitChildren(self)




    def consultaPOLY(self):

        localctx = poliParser.ConsultaPOLYContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_consultaPOLY)
        self._la = 0 # Token type
        try:
            self.state = 120
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [poliParser.CMDAREA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 89
                self.match(poliParser.CMDAREA)
                self.state = 90
                self.poly()
                pass
            elif token in [poliParser.CMDPERIMETRE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 91
                self.match(poliParser.CMDPERIMETRE)
                self.state = 92
                self.poly()
                pass
            elif token in [poliParser.CMDVERTICES]:
                self.enterOuterAlt(localctx, 3)
                self.state = 93
                self.match(poliParser.CMDVERTICES)
                self.state = 94
                self.poly()
                pass
            elif token in [poliParser.CMDCENTROID]:
                self.enterOuterAlt(localctx, 4)
                self.state = 95
                self.match(poliParser.CMDCENTROID)
                self.state = 96
                self.poly()
                pass
            elif token in [poliParser.CMDPRINT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 97
                self.match(poliParser.CMDPRINT)
                self.state = 98
                self.poly()
                pass
            elif token in [poliParser.CMDEQ]:
                self.enterOuterAlt(localctx, 6)
                self.state = 99
                self.match(poliParser.CMDEQ)
                self.state = 100
                self.poly()
                self.state = 101
                self.match(poliParser.COMA)
                self.state = 102
                self.poly()
                pass
            elif token in [poliParser.CMDINSIDE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 104
                self.match(poliParser.CMDINSIDE)
                self.state = 105
                self.poly()
                self.state = 106
                self.match(poliParser.COMA)
                self.state = 107
                self.poly()
                pass
            elif token in [poliParser.CMDDRAW]:
                self.enterOuterAlt(localctx, 8)
                self.state = 109
                self.match(poliParser.CMDDRAW)
                self.state = 110
                self.match(poliParser.TXT)
                self.state = 111
                self.match(poliParser.COMA)
                self.state = 112
                self.poly()
                self.state = 117
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==poliParser.COMA:
                    self.state = 113
                    self.match(poliParser.COMA)
                    self.state = 114
                    self.poly()
                    self.state = 119
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrintMSGContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CMDPRINT(self):
            return self.getToken(poliParser.CMDPRINT, 0)

        def TXT(self):
            return self.getToken(poliParser.TXT, 0)

        def getRuleIndex(self):
            return poliParser.RULE_printMSG

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintMSG" ):
                return visitor.visitPrintMSG(self)
            else:
                return visitor.visitChildren(self)




    def printMSG(self):

        localctx = poliParser.PrintMSGContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_printMSG)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(poliParser.CMDPRINT)
            self.state = 123
            self.match(poliParser.TXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OperacionsPOLY1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATORBOUNDINGBOX(self):
            return self.getToken(poliParser.OPERATORBOUNDINGBOX, 0)

        def poly(self):
            return self.getTypedRuleContext(poliParser.PolyContext,0)


        def OPERATORRANDOMPOLY(self):
            return self.getToken(poliParser.OPERATORRANDOMPOLY, 0)

        def INT(self):
            return self.getToken(poliParser.INT, 0)

        def getRuleIndex(self):
            return poliParser.RULE_operacionsPOLY1

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperacionsPOLY1" ):
                return visitor.visitOperacionsPOLY1(self)
            else:
                return visitor.visitChildren(self)




    def operacionsPOLY1(self):

        localctx = poliParser.OperacionsPOLY1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_operacionsPOLY1)
        try:
            self.state = 129
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [poliParser.OPERATORBOUNDINGBOX]:
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                self.match(poliParser.OPERATORBOUNDINGBOX)
                self.state = 126
                self.poly()
                pass
            elif token in [poliParser.OPERATORRANDOMPOLY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 127
                self.match(poliParser.OPERATORRANDOMPOLY)
                self.state = 128
                self.match(poliParser.INT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OperacionsPOLY2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def polyID(self):
            return self.getTypedRuleContext(poliParser.PolyIDContext,0)


        def OPERATORUNION(self):
            return self.getToken(poliParser.OPERATORUNION, 0)

        def poly(self):
            return self.getTypedRuleContext(poliParser.PolyContext,0)


        def OPERATORINTER(self):
            return self.getToken(poliParser.OPERATORINTER, 0)

        def getRuleIndex(self):
            return poliParser.RULE_operacionsPOLY2

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperacionsPOLY2" ):
                return visitor.visitOperacionsPOLY2(self)
            else:
                return visitor.visitChildren(self)




    def operacionsPOLY2(self):

        localctx = poliParser.OperacionsPOLY2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_operacionsPOLY2)
        try:
            self.state = 139
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 131
                self.polyID()
                self.state = 132
                self.match(poliParser.OPERATORUNION)
                self.state = 133
                self.poly()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 135
                self.polyID()
                self.state = 136
                self.match(poliParser.OPERATORINTER)
                self.state = 137
                self.poly()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PolyIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(poliParser.ID, 0)

        def getRuleIndex(self):
            return poliParser.RULE_polyID

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPolyID" ):
                return visitor.visitPolyID(self)
            else:
                return visitor.visitChildren(self)




    def polyID(self):

        localctx = poliParser.PolyIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_polyID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.match(poliParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





